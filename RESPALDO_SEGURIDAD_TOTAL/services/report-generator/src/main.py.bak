"""
Generador de Reportes - Servicio Principal COMPLETO
Puerto: 8004
Archivo: services/report-generator/src/main.py
"""

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import Response
from pydantic import BaseModel
import uvicorn
import os
import json
import logging
import base64
from datetime import datetime
from typing import Dict, List, Optional, Any, Union
from pathlib import Path
import io

# Generaci√≥n de PDFs
try:
    from reportlab.lib import colors
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    REPORTLAB_AVAILABLE = True
except ImportError:
    REPORTLAB_AVAILABLE = False
    logging.warning("‚ö†Ô∏è ReportLab no disponible - generaci√≥n PDF limitada")

# Templates
try:
    from jinja2 import Template
    JINJA2_AVAILABLE = True
except ImportError:
    JINJA2_AVAILABLE = False
    logging.warning("‚ö†Ô∏è Jinja2 no disponible - templates limitados")

import pandas as pd
import numpy as np

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ===================================================================
# CONFIGURACI√ìN DE DIRECTORIOS
# ===================================================================

BASE_DIR = Path(__file__).parent.parent
REPORTS_DIR = BASE_DIR / "data" / "reports"
TEMPLATES_DIR = BASE_DIR / "templates"

REPORTS_DIR.mkdir(parents=True, exist_ok=True)
TEMPLATES_DIR.mkdir(parents=True, exist_ok=True)

# ===================================================================
# MODELOS DE DATOS
# ===================================================================

class ReportRequest(BaseModel):
    title: str
    subtitle: Optional[str] = None
    author: str = "Agente IA OyP 6.0"
    data: Optional[Dict[str, Any]] = None
    sections: List[Dict[str, Any]] = []
    template: str = "standard"
    format: str = "pdf"  # pdf, html, json
    include_charts: bool = True
    include_tables: bool = True

class Section(BaseModel):
    title: str
    content: str
    type: str = "text"  # text, table, chart, analysis
    data: Optional[Dict[str, Any]] = None

class QuickReportRequest(BaseModel):
    title: str
    content: str
    format: str = "pdf"
    author: str = "Agente IA OyP 6.0"

# ===================================================================
# APLICACI√ìN FASTAPI
# ===================================================================

app = FastAPI(
    title="üìã Generador de Reportes - Agente IA OyP 6.0",
    description="Generador autom√°tico de reportes profesionales en PDF, HTML y JSON",
    version="6.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Configurar CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

    
    def setup_templates(self) -> Dict[str, Any]:
        """Configurar templates predefinidos"""
        return {
            "standard": {
                "name": "Reporte Est√°ndar",
                "description": "Template b√°sico para reportes generales",
                "sections": ["header", "summary", "content", "conclusions"]
            },
            "analytics": {
                "name": "Reporte de Analytics",
                "description": "Template para an√°lisis de datos",
                "sections": ["header", "executive_summary", "data_analysis", "visualizations", "insights", "recommendations"]
            },
            "document_analysis": {
                "name": "An√°lisis Documental",
                "description": "Template para an√°lisis de documentos",
                "sections": ["header", "document_info", "content_analysis", "key_findings", "summary"]
            }
        }
    
    # ===================================================================
    # GENERACI√ìN PDF
    # ===================================================================
    
    async def generate_pdf_report(self, content: Dict[str, Any], request: ReportRequest) -> Dict[str, Any]:
        """Generar reporte PDF"""
        try:
            if not REPORTLAB_AVAILABLE:
                return await self.generate_fallback_report(content, "pdf")
            
            buffer = io.BytesIO()
            
            # Configurar documento
            doc = SimpleDocTemplate(
                buffer,
                pagesize=A4,
                rightMargin=72,
                leftMargin=72,
                topMargin=72,
                bottomMargin=72
            )
            
            # Estilos
            styles = getSampleStyleSheet()
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=24,
                spaceAfter=30,
                alignment=1,  # Centrado
                textColor=colors.darkblue
            )
            
            subtitle_style = ParagraphStyle(
                'CustomSubtitle',
                parent=styles['Heading2'],
                fontSize=16,
                spaceAfter=20,
                alignment=1,
                textColor=colors.grey
            )
            
            section_title_style = ParagraphStyle(
                'SectionTitle',
                parent=styles['Heading2'],
                fontSize=14,
                spaceAfter=12,
                textColor=colors.darkblue
            )
            
            # Elementos del documento
            elements = []
            
            # T√≠tulo principal
            title = Paragraph(content["metadata"]["title"], title_style)
            elements.append(title)
            elements.append(Spacer(1, 12))
            
            # Subt√≠tulo
            if content["metadata"].get("subtitle"):
                subtitle = Paragraph(content["metadata"]["subtitle"], subtitle_style)
                elements.append(subtitle)
                elements.append(Spacer(1, 20))
            
            # Informaci√≥n del reporte
            info_data = [
                ["Autor:", content["metadata"]["author"]],
                ["Fecha de generaci√≥n:", content["metadata"]["generated_at"]],
                ["Template utilizado:", content["metadata"]["template"].title()],
                ["N√∫mero de secciones:", str(len(content["sections"]))]
            ]
            
            info_table = Table(info_data, colWidths=[2*inch, 4*inch])
            info_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),
                ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
                ('ALIGN', (0, 0), (0, -1), 'RIGHT'),
                ('ALIGN', (1, 0), (1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            
            elements.append(info_table)
            elements.append(Spacer(1, 30))
            
            # Secciones del contenido
            for section in content["sections"]:
                # T√≠tulo de secci√≥n
                section_title = Paragraph(section["title"], section_title_style)
                elements.append(section_title)
                elements.append(Spacer(1, 12))
                
                # Contenido de secci√≥n
                if section["type"] == "text":
                    # Texto normal
                    paragraphs = section["content"].split('\n\n')
                    for para in paragraphs:
                        if para.strip():
                            text_para = Paragraph(para.strip(), styles['Normal'])
                            elements.append(text_para)
                            elements.append(Spacer(1, 6))
                
                elif section["type"] == "table" and section.get("formatted_table"):
                    # Tabla de datos
                    table_data = section["formatted_table"]
                    if table_data["rows"]:
                        # Limitar filas para PDF
                        pdf_rows = table_data["rows"][:15]  # M√°ximo 15 filas
                        pdf_table_data = [table_data["headers"]] + pdf_rows
                        
                        # Ajustar ancho de columnas
                        col_count = len(table_data["headers"])
                        col_width = 6.5 * inch / col_count
                        
                        table = Table(pdf_table_data, colWidths=[col_width] * col_count)
                        table.setStyle(TableStyle([
                            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                            ('FONTSIZE', (0, 0), (-1, 0), 10),
                            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                            ('FONTSIZE', (0, 1), (-1, -1), 8),
                            ('GRID', (0, 0), (-1, -1), 1, colors.black),
                            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])
                        ]))
                        
                        elements.append(table)
                        
                        # Nota si se truncaron filas
                        if len(table_data["rows"]) > 15:
                            note = Paragraph(f"<i>Nota: Mostrando primeras 15 filas de {len(table_data['rows'])} totales</i>", styles['Normal'])
                            elements.append(note)
                
                elif section["type"] == "analysis":
                    # Contenido de an√°lisis
                    analysis_paras = section["content"].split('\n')
                    for para in analysis_paras:
                        if para.strip():
                            if para.startswith('##'):
                                # Subt√≠tulo
                                subtitle_text = para.replace('##', '').strip()
                                subtitle_para = Paragraph(subtitle_text, styles['Heading3'])
                                elements.append(subtitle_para)
                            elif para.startswith('**') and para.endswith('**'):
                                # Texto en negrita
                                bold_text = para.replace('**', '')
                                bold_para = Paragraph(f"<b>{bold_text}</b>", styles['Normal'])
                                elements.append(bold_para)
                            else:
                                # Texto normal
                                text_para = Paragraph(para.strip(), styles['Normal'])
                                elements.append(text_para)
                    
                    # Resumen de an√°lisis si existe
                    if section.get("analysis_summary"):
                        elements.append(Spacer(1, 10))
                        summary_para = Paragraph(f"<b>Resumen:</b> {section['analysis_summary']}", styles['Normal'])
                        elements.append(summary_para)
                
                elements.append(Spacer(1, 20))
            
            # Footer
            footer_style = ParagraphStyle(
                'Footer',
                parent=styles['Normal'],
                fontSize=8,
                alignment=1,
                textColor=colors.grey
            )
            
            elements.append(Spacer(1, 30))
            footer = Paragraph("Generado autom√°ticamente por Agente IA OyP 6.0", footer_style)
            elements.append(footer)
            
            # Construir PDF
            doc.build(elements)
            
            # Obtener contenido
            pdf_content = buffer.getvalue()
            buffer.close()
            
            # Codificar en base64
            pdf_base64 = base64.b64encode(pdf_content).decode('utf-8')
            
            return {
                "content": pdf_base64,
                "content_type": "application/pdf",
                "size": len(pdf_content),
                "encoding": "base64",
                "filename": f"{content['metadata']['title'].replace(' ', '_')}.pdf"
            }
            
        except Exception as e:
            logger.error(f"‚ùå Error generando PDF: {e}")
            return await self.generate_fallback_report(content, "pdf")
    
    # ===================================================================
    # GENERACI√ìN HTML
    # ===================================================================
    
    async def generate_html_report(self, content: Dict[str, Any], request: ReportRequest) -> Dict[str, Any]:
        """Generar reporte HTML"""
        try:
            html_template = """
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; padding: 40px; line-height: 1.6; 
            background-color: #f8f9fa; color: #333;
        }
        .container { 
            max-width: 1200px; margin: 0 auto; 
            background: white; padding: 40px; border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        .header { 
            text-align: center; border-bottom: 3px solid #007bff; 
            padding-bottom: 30px; margin-bottom: 40px; 
        }
        .title { 
            color: #007bff; font-size: 32px; margin-bottom: 10px; 
            font-weight: 300; letter-spacing: 1px;
        }
        .subtitle { 
            color: #6c757d; font-size: 20px; font-weight: 300; 
        }
        .info-box { 
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); 
            padding: 25px; border-radius: 8px; margin-bottom: 40px;
            border-left: 5px solid #007bff;
        }
        .info-grid {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 15px; font-size: 14px;
        }
        .info-item { display: flex; }
        .info-label { font-weight: bold; min-width: 140px; color: #495057; }
        .info-value { color: #212529; }
        .section { 
            margin-bottom: 40px; border-radius: 8px;
            border: 1px solid #e9ecef; overflow: hidden;
        }
        .section-header {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white; padding: 15px 25px; margin: 0;
            font-size: 20px; font-weight: 500;
        }
        .section-content { 
            padding: 25px; background: white;
        }
        .content { text-align: justify; }
        .content h2 { color: #007bff; font-size: 18px; margin-top: 25px; }
        .content h3 { color: #495057; font-size: 16px; }
        table { 
            width: 100%; border-collapse: collapse; margin: 20px 0; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1); border-radius: 8px;
            overflow: hidden;
        }
        th { 
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); 
            color: white; padding: 15px 12px; text-align: left; 
            font-weight: 600; font-size: 14px;
        }
        td { 
            border: 1px solid #e9ecef; padding: 12px; 
            background: white; font-size: 13px;
        }
        tr:nth-child(even) td { background-color: #f8f9fa; }
        tr:hover td { background-color: #e3f2fd; transition: all 0.3s ease; }
        .analysis { 
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%); 
            padding: 20px; border-radius: 8px; margin: 20px 0;
            border-left: 5px solid #ffc107;
        }
        .analysis h2 { color: #856404; margin-top: 0; }
        .footer { 
            text-align: center; margin-top: 60px; color: #6c757d; 
            font-size: 12px; padding-top: 20px; 
            border-top: 1px solid #e9ecef;
        }
        .stats-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px; margin: 20px 0;
        }
        .stat-card {
            background: white; padding: 20px; border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center;
        }
        .stat-number { font-size: 24px; font-weight: bold; color: #007bff; }
        .stat-label { color: #6c757d; font-size: 14px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">{{ title }}</h1>
            {% if subtitle %}<p class="subtitle">{{ subtitle }}</p>{% endif %}
        </div>
        
        <div class="info-box">
            <div class="info-grid">
                <div class="info-item">
                    <span class="info-label">Autor:</span>
                    <span class="info-value">{{ author }}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Fecha:</span>
                    <span class="info-value">{{ generated_at }}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Template:</span>
                    <span class="info-value">{{ template }}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Secciones:</span>
                    <span class="info-value">{{ section_count }}</span>
                </div>
            </div>
        </div>
        
        {% for section in sections %}
        <div class="section">
            <h2 class="section-header">{{ section.title }}</h2>
            <div class="section-content">
                {% if section.type == 'text' %}
                    <div class="content">
                        {% for paragraph in section.content.split('\n\n') %}
                            {% if paragraph.strip() %}
                                <p>{{ paragraph|replace('\n', '<br>')|safe }}</p>
                            {% endif %}
                        {% endfor %}
                    </div>
                {% elif section.type == 'table' and section.formatted_table %}
                    <table>
                        <thead>
                            <tr>
                                {% for header in section.formatted_table.headers %}
                                <th>{{ header }}</th>
                                {% endfor %}
                            </tr>
                        </thead>
                        <tbody>
                            {% for row in section.formatted_table.rows[:50] %}
                            <tr>
                                {% for cell in row %}
                                <td>{{ cell }}</td>
                                {% endfor %}
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                    {% if section.formatted_table.rows|length > 50 %}
                        <p><em>Mostrando primeras 50 filas de {{ section.formatted_table.rows|length }} totales</em></p>
                    {% endif %}
                {% elif section.type == 'analysis' %}
                    <div class="analysis">
                        {{ section.content|replace('##', '<h2>')|replace('\n', '<br>')|safe }}
                        {% if section.analysis_summary %}
                        <br><br><strong>Resumen:</strong> {{ section.analysis_summary }}
                        {% endif %}
                    </div>
                {% else %}
                    <div class="content">
                        <p>{{ section.content|replace('\n', '<br>')|safe }}</p>
                    </div>
                {% endif %}
            </div>
        </div>
        {% endfor %}
        
        <div class="footer">
            <p>üìã Generado autom√°ticamente por <strong>Agente IA OyP 6.0</strong> - Report Generator Service</p>
            <p>Fecha de generaci√≥n: {{ generated_at }}</p>
        </div>
    </div>
</body>
</html>
"""
            
            if JINJA2_AVAILABLE:
                template = Template(html_template)
                html_content = template.render(
                    title=content["metadata"]["title"],
                    subtitle=content["metadata"].get("subtitle"),
                    author=content["metadata"]["author"],
                    generated_at=content["metadata"]["generated_at"],
                    template=content["metadata"]["template"].title(),
                    section_count=len(content["sections"]),
                    sections=content["sections"]
                )
            else:
                # Fallback simple sin Jinja2
                html_content = html_template
                html_content = html_content.replace("{{ title }}", content["metadata"]["title"])
                html_content = html_content.replace("{{ author }}", content["metadata"]["author"])
                html_content = html_content.replace("{{ generated_at }}", content["metadata"]["generated_at"])
                html_content = html_content.replace("{{ template }}", content["metadata"]["template"])
                # Simplificar secciones para fallback
                sections_html = ""
                for section in content["sections"]:
                    sections_html += f"<div class='section'><h2 class='section-header'>{section['title']}</h2>"
                    sections_html += f"<div class='section-content'><p>{section['content']}</p></div></div>"
                html_content = html_content.replace("{% for section in sections %}...{% endfor %}", sections_html)
            
            return {
                "content": html_content,
                "content_type": "text/html",
                "size": len(html_content.encode('utf-8')),
                "encoding": "utf-8",
                "filename": f"{content['metadata']['title'].replace(' ', '_')}.html"
            }
            
        except Exception as e:
            logger.error(f"‚ùå Error generando HTML: {e}")
            return await self.generate_fallback_report(content, "html")
    
    # ===================================================================
    # GENERACI√ìN JSON
    # ===================================================================
    
    async def generate_json_report(self, content: Dict[str, Any], request: ReportRequest) -> Dict[str, Any]:
        """Generar reporte JSON"""
        try:
            json_content = json.dumps(content, indent=2, ensure_ascii=False)
            
            return {
                "content": json_content,
                "content_type": "application/json",
                "size": len(json_content.encode('utf-8')),
                "encoding": "utf-8",
                "filename": f"{content['metadata']['title'].replace(' ', '_')}.json"
            }
            
        except Exception as e:
            logger.error(f"‚ùå Error generando JSON: {e}")
            return await self.generate_fallback_report(content, "json")
    
    async def generate_fallback_report(self, content: Dict[str, Any], format_type: str) -> Dict[str, Any]:
        """Generar reporte de respaldo"""
        try:
            fallback_content = f"""
REPORTE - {content['metadata']['title']}
{'=' * 50}

Autor: {content['metadata']['author']}
Fecha: {content['metadata']['generated_at']}
Template: {content['metadata']['template']}

CONTENIDO:
"""
            
            for i, section in enumerate(content.get("sections", []), 1):
                fallback_content += f"\n{i}. {section['title']}\n"
                fallback_content += f"{'-' * 30}\n"
                fallback_content += f"{section['content']}\n"
                if section.get("analysis_summary"):
                    fallback_content += f"Resumen: {section['analysis_summary']}\n"
                fallback_content += "\n"
            
            fallback_content += f"\nGenerado por Agente IA OyP 6.0 (Report Generator - Modo Respaldo)\nFormato solicitado: {format_type}"
            
            return {
                "content": fallback_content,
                "content_type": "text/plain",
                "size": len(fallback_content.encode('utf-8')),
                "encoding": "utf-8",
                "fallback": True,
                "filename": f"{content['metadata']['title'].replace(' ', '_')}_fallback.txt"
            }
            
        except Exception as e:
            logger.error(f"‚ùå Error generando fallback: {e}")
            return {
                "content": f"Error generando reporte: {str(e)}",
                "content_type": "text/plain",
                "size": 0,
                "encoding": "utf-8",
                "error": True
            }

# ===================================================================
# INSTANCIA GLOBAL DEL SERVICIO
# ===================================================================

report_service = ReportGeneratorService()

# ===================================================================
# ENDPOINTS DE LA API
# ===================================================================

@app.get("/")
async def root():
    """Endpoint ra√≠z con informaci√≥n del servicio"""
    return {
        "message": "üìã Bienvenido al Generador de Reportes - Agente IA OyP 6.0",
        "service": "report-generator",
        "version": "6.0.0",
        "status": "active",
        "supported_formats": ["pdf", "html", "json"],
        "capabilities": [
            "pdf_generation",
            "html_reports",
            "json_export",
            "template_system",
            "automatic_sections",
            "table_formatting",
            "analysis_integration"
        ]
    }

@app.get("/health")
async def health_check():
    """Health check del servicio"""
    return {
        "status": "healthy",
        "service": "report-generator",
        "port": 8004,
        "timestamp": datetime.now().isoformat(),
        "dependencies": {
            "reportlab": REPORTLAB_AVAILABLE,
            "jinja2": JINJA2_AVAILABLE
        },
        "generated_reports": len(report_service.generated_reports),
        "available_templates": len(report_service.templates)
    }

@app.get("/info")
async def service_info():
    """Informaci√≥n detallada del servicio"""
    return {
        "name": "report-generator",
        "description": "Generador autom√°tico de reportes profesionales en m√∫ltiples formatos",
        "port": 8004,
        "version": "6.0.0",
        "endpoints": {
            "GET /": "Informaci√≥n del servicio",
            "GET /health": "Health check",
            "GET /info": "Informaci√≥n detallada",
            "POST /generate": "Generar reporte completo",
            "POST /quick_report": "Generar reporte r√°pido",
            "GET /templates": "Listar templates disponibles",
            "GET /reports": "Listar reportes generados",
            "GET /report/{id}": "Obtener informaci√≥n de reporte"
        }
    }

@app.post("/generate")
async def generate_report_endpoint(request: ReportRequest):
    """Generar reporte completo"""
    return await report_service.generate_report(request)

@app.post("/quick_report")
async def quick_report(request: QuickReportRequest):
    """Generar reporte r√°pido con contenido simple"""
    full_request = ReportRequest(
        title=request.title,
        author=request.author,
        format=request.format,
        sections=[{
            "title": "Contenido Principal",
            "type": "text",
            "content": request.content
        }]
    )
    
    return await report_service.generate_report(full_request)

@app.get("/templates")
async def list_templates():
    """Listar templates disponibles"""
    return {
        "templates": report_service.templates,
        "total_templates": len(report_service.templates)
    }

@app.get("/reports")
async def list_reports():
    """Listar reportes generados"""
    return {
        "reports": list(report_service.generated_reports.values()),
        "total_reports": len(report_service.generated_reports)
    }

@app.get("/report/{report_id}")
async def get_report_info(report_id: str):
    """Obtener informaci√≥n de reporte espec√≠fico"""
    if report_id in report_service.generated_reports:
        return report_service.generated_reports[report_id]
    else:
        raise HTTPException(status_code=404, detail="Reporte no encontrado")

@app.delete("/report/{report_id}")
async def delete_report(report_id: str):
    """Eliminar reporte del cach√©"""
    if report_id in report_service.generated_reports:
        del report_service.generated_reports[report_id]
        return {"message": "Reporte eliminado", "report_id": report_id}
    else:
        raise HTTPException(status_code=404, detail="Reporte no encontrado")

@app.get("/statistics")
async def get_generation_statistics():
    """Estad√≠sticas del servicio de generaci√≥n"""
    reports = report_service.generated_reports
    
    # Estad√≠sticas por formato
    format_stats = {}
    for report in reports.values():
        format_type = report.get('format', 'unknown')
        format_stats[format_type] = format_stats.get(format_type, 0) + 1
    
    # Estad√≠sticas por template
    template_stats = {}
    for report in reports.values():
        if 'request' in report:
            template = report['request'].get('template', 'unknown')
            template_stats[template] = template_stats.get(template, 0) + 1
    
    return {
        "total_reports_generated": len(reports),
        "reports_by_format": format_stats,
        "reports_by_template": template_stats,
        "service_uptime": datetime.now().isoformat(),
        "dependencies_status": {
            "pdf_generation": REPORTLAB_AVAILABLE,
            "html_templates": JINJA2_AVAILABLE
        },
        "available_templates": list(report_service.templates.keys())
    }

@app.post("/test_generation")
async def test_report_generation():
    """Endpoint para probar la generaci√≥n de reportes"""
    test_request = ReportRequest(
        title="Reporte de Prueba",
        subtitle="Generado autom√°ticamente para verificar funcionalidad",
        author="Sistema de Pruebas",
        format="html",
        sections=[
            {
                "title": "Introducci√≥n",
                "type": "text",
                "content": "Este es un reporte de prueba generado autom√°ticamente para verificar que el servicio de generaci√≥n de reportes funciona correctamente."
            },
            {
                "title": "Datos de Ejemplo",
                "type": "table",
                "content": "Tabla con datos de ejemplo para demostrar las capacidades.",
                "data": {
                    "headers": ["ID", "Nombre", "Valor", "Estado"],
                    "rows": [
                        ["1", "Item A", "100", "Activo"],
                        ["2", "Item B", "200", "Inactivo"],
                        ["3", "Item C", "150", "Activo"]
                    ]
                }
            },
            {
                "title": "An√°lisis",
                "type": "analysis",
                "content": "## Resultados del An√°lisis\n\nEl an√°lisis muestra resultados satisfactorios:\n\n**Elementos activos**: 2 de 3 (66.7%)\n\n**Valor promedio**: 150",
                "data": {
                    "mean": 150,
                    "count": 3,
                    "active_percentage": 66.7
                }
            }
        ]
    )
    
    return await report_service.generate_report(test_request)

# ===================================================================
# INICIALIZACI√ìN DEL SERVICIO
# ===================================================================

if __name__ == "__main__":
    logger.info("üöÄ Iniciando Report Generator Service...")
    logger.info("üìç Puerto: 8004")
    logger.info("üìñ Documentaci√≥n: http://localhost:8004/docs")
    logger.info(f"üìÑ ReportLab: {'‚úÖ' if REPORTLAB_AVAILABLE else '‚ùå'}")
    logger.info(f"üé® Jinja2: {'‚úÖ' if JINJA2_AVAILABLE else '‚ùå'}")
    logger.info(f"üìÅ Reports dir: {REPORTS_DIR}")
    logger.info("üìã Formatos soportados: PDF, HTML, JSON")
    
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8004,
        reload=True,
        log_level="info"
    )
app = FastAPI(
    title="üìã Generador de Reportes - Agente IA OyP 6.0",
    description="Generador autom√°tico de reportes profesionales en PDF, HTML y JSON",
    version="6.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Configurar CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

    
    def setup_templates(self) -> Dict[str, Any]:
        """Configurar templates predefinidos"""
        return {
            "standard": {
                "name": "Reporte Est√°ndar",
                "description": "Template b√°sico para reportes generales",
                "sections": ["header", "summary", "content", "conclusions"]
            },
            "analytics": {
                "name": "Reporte de Analytics",
                "description": "Template para an√°lisis de datos",
                "sections": ["header", "executive_summary", "data_analysis", "visualizations", "insights", "recommendations"]
            },
            "document_analysis": {
                "name": "An√°lisis Documental",
                "description": "Template para an√°lisis de documentos",
                "sections": ["header", "document_info", "content_analysis", "key_findings", "summary"]
            }
        }
    
    # ===================================================================
    # GENERACI√ìN DE REPORTES
    # ===================================================================
    
    async def generate_report(self, request: ReportRequest) -> Dict[str, Any]:
        """Generar reporte completo"""
        try:
            report_id = f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            # Construir contenido del reporte
            report_content = await self.build_report_content(request)
            
            # Generar seg√∫n formato
            if request.format == "pdf":
                report_data = await self.generate_pdf_report(report_content, request)
            elif request.format == "html":
                report_data = await self.generate_html_report(report_content, request)
            elif request.format == "json":
                report_data = await self.generate_json_report(report_content, request)
            else:
                raise ValueError(f"Formato {request.format} no soportado")
            
            # Guardar reporte
            self.generated_reports[report_id] = {
                "id": report_id,
                "title": request.title,
                "format": request.format,
                "generated_at": datetime.now().isoformat(),
                "size": len(str(report_data.get("content", ""))),
                "request": request.dict()
            }
            
            return {
                "report_id": report_id,
                "title": request.title,
                "format": request.format,
                "generated_at": datetime.now().isoformat(),
                "status": "completed",
                **report_data
            }
            
        except Exception as e:
            logger.error(f"‚ùå Error generando reporte: {e}")
            raise HTTPException(status_code=500, detail=f"Error generando reporte: {str(e)}")
    
    async def build_report_content(self, request: ReportRequest) -> Dict[str, Any]:
        """Construir contenido estructurado del reporte"""
        try:
            content = {
                "metadata": {
                    "title": request.title,
                    "subtitle": request.subtitle,
                    "author": request.author,
                    "generated_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "template": request.template
                },
                "sections": [],
                "statistics": {}
            }
            
            # Procesar secciones del request
            for section_data in request.sections:
                processed_section = await self.process_section(section_data)
                content["sections"].append(processed_section)
            
            # Generar secciones autom√°ticas si hay datos
            if request.data:
                auto_sections = await self.generate_auto_sections(request.data, request.template)
                content["sections"].extend(auto_sections)
            
            return content
            
        except Exception as e:
            logger.error(f"‚ùå Error construyendo contenido: {e}")
            raise ValueError(f"Error construyendo contenido: {str(e)}")
    
    async def process_section(self, section_data: Dict[str, Any]) -> Dict[str, Any]:
        """Procesar una secci√≥n individual"""
        try:
            processed = {
                "title": section_data.get("title", "Sin t√≠tulo"),
                "type": section_data.get("type", "text"),
                "content": section_data.get("content", ""),
                "data": section_data.get("data", {})
            }
            
            # Procesamiento espec√≠fico por tipo
            if processed["type"] == "table" and processed["data"]:
                processed["formatted_table"] = self.format_table_data(processed["data"])
            elif processed["type"] == "analysis" and processed["data"]:
                processed["analysis_summary"] = self.generate_analysis_summary(processed["data"])
            
            return processed
            
        except Exception as e:
            logger.error(f"‚ùå Error procesando secci√≥n: {e}")
            return {"title": "Error", "content": f"Error procesando secci√≥n: {str(e)}"}
    
    async def generate_auto_sections(self, data: Dict[str, Any], template: str) -> List[Dict[str, Any]]:
        """Generar secciones autom√°ticas basadas en datos"""
        try:
            sections = []
            
            # Secci√≥n de resumen de datos
            if "statistics" in data or "summary" in data:
                sections.append({
                    "title": "Resumen Ejecutivo",
                    "type": "analysis",
                    "content": self.generate_executive_summary(data),
                    "data": data.get("statistics", {})
                })
            
            # Secci√≥n de an√°lisis de datos
            if "analysis" in data:
                sections.append({
                    "title": "An√°lisis de Datos",
                    "type": "analysis",
                    "content": self.format_analysis_results(data["analysis"]),
                    "data": data["analysis"]
                })
            
            # Secci√≥n de tablas
            if "tables" in data or "dataframe" in data:
                sections.append({
                    "title": "Datos Tabulares",
                    "type": "table",
                    "content": "Presentaci√≥n de los datos en formato tabular para an√°lisis detallado.",
                    "data": data.get("tables", data.get("dataframe", []))
                })
            
            # Secci√≥n de hallazgos clave
            if "insights" in data or "findings" in data:
                sections.append({
                    "title": "Hallazgos Principales",
                    "type": "text",
                    "content": data.get("insights", data.get("findings", "")),
                    "data": {}
                })
            
            # Secci√≥n de recomendaciones
            if "recommendations" in data:
                sections.append({
                    "title": "Recomendaciones",
                    "type": "text",
                    "content": data["recommendations"],
                    "data": {}
                })
            
            return sections
            
        except Exception as e:
            logger.error(f"‚ùå Error generando secciones autom√°ticas: {e}")
            return []
    
    def generate_executive_summary(self, data: Dict[str, Any]) -> str:
        """Generar resumen ejecutivo"""
        try:
            summary_parts = []
            
            # Informaci√≥n del dataset
            if "statistics" in data:
                stats = data["statistics"]
                if "rows" in stats and "columns" in stats:
                    summary_parts.append(f"**Datos analizados:** {stats['rows']:,} registros con {stats['columns']} variables.")
                
                if "data_quality" in stats:
                    quality = stats["data_quality"]
                    completeness = quality.get("completeness", 0)
                    summary_parts.append(f"**Calidad de datos:** {completeness:.1f}% de completitud.")
            
            # Correlaciones significativas
            if "correlations" in data:
                corr_data = data["correlations"]
                if "strong_correlations" in corr_data:
                    strong_count = len(corr_data["strong_correlations"])
                    if strong_count > 0:
                        summary_parts.append(f"**Correlaciones identificadas:** {strong_count} correlaciones estad√≠sticamente significativas.")
            
            # Clustering
            if "clustering" in data:
                cluster_data = data["clustering"]
                if "optimal_clusters" in cluster_data:
                    clusters = cluster_data["optimal_clusters"]
                    summary_parts.append(f"**Segmentaci√≥n:** Los datos se organizan naturalmente en {clusters} grupos distintos.")
            
            # Outliers
            if "outliers" in data:
                outlier_data = data["outliers"]
                total_outliers = sum(info.get("count", 0) for info in outlier_data.values() if isinstance(info, dict))
                if total_outliers > 0:
                    summary_parts.append(f"**Valores at√≠picos:** Se detectaron {total_outliers} valores que requieren atenci√≥n especial.")
            
            if not summary_parts:
                summary_parts.append("Se ha completado el an√°lisis de los datos proporcionados con resultados satisfactorios.")
            
            return "\n\n".join(summary_parts)
            
        except Exception as e:
            logger.error(f"‚ùå Error generando resumen ejecutivo: {e}")
            return "Resumen ejecutivo no disponible debido a un error en el procesamiento."
    
    def format_analysis_results(self, analysis: Dict[str, Any]) -> str:
        """Formatear resultados de an√°lisis"""
        try:
            content_parts = []
            
            # Estad√≠sticas descriptivas
            if "descriptive_stats" in analysis:
                content_parts.append("## Estad√≠sticas Descriptivas\n")
                content_parts.