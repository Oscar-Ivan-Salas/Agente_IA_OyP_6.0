"""
Generador de Reportes - Servicio Principal COMPLETO
Puerto: 8004
Archivo: services/report-generator/src/main.py
"""

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import Response
from pydantic import BaseModel
import uvicorn
import os
import json
import logging
import base64
from datetime import datetime
from typing import Dict, List, Optional, Any, Union
from pathlib import Path
import io

# Generación de PDFs
try:
    from reportlab.lib import colors
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    REPORTLAB_AVAILABLE = True
except ImportError:
    REPORTLAB_AVAILABLE = False
    logging.warning("⚠️ ReportLab no disponible - generación PDF limitada")

# Templates
try:
    from jinja2 import Template
    JINJA2_AVAILABLE = True
except ImportError:
    JINJA2_AVAILABLE = False
    logging.warning("⚠️ Jinja2 no disponible - templates limitados")

import pandas as pd
import numpy as np

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ===================================================================
# CONFIGURACIÓN DE DIRECTORIOS
# ===================================================================

BASE_DIR = Path(__file__).parent.parent
REPORTS_DIR = BASE_DIR / "data" / "reports"
TEMPLATES_DIR = BASE_DIR / "templates"

REPORTS_DIR.mkdir(parents=True, exist_ok=True)
TEMPLATES_DIR.mkdir(parents=True, exist_ok=True)

# ===================================================================
# MODELOS DE DATOS
# ===================================================================

class ReportRequest(BaseModel):
    title: str
    subtitle: Optional[str] = None
    author: str = "Agente IA OyP 6.0"
    data: Optional[Dict[str, Any]] = None
    sections: List[Dict[str, Any]] = []
    template: str = "standard"
    format: str = "pdf"  # pdf, html, json
    include_charts: bool = True
    include_tables: bool = True

class Section(BaseModel):
    title: str
    content: str
    type: str = "text"  # text, table, chart, analysis
    data: Optional[Dict[str, Any]] = None

class QuickReportRequest(BaseModel):
    title: str
    content: str
    format: str = "pdf"
    author: str = "Agente IA OyP 6.0"

# ===================================================================
# APLICACIÓN FASTAPI
# ===================================================================

app = FastAPI(
    title="📋 Generador de Reportes - Agente IA OyP 6.0",
    description="Generador automático de reportes profesionales en PDF, HTML y JSON",
    version="6.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Configurar CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

    
    def setup_templates(self) -> Dict[str, Any]:
        """Configurar templates predefinidos"""
        return {
            "standard": {
                "name": "Reporte Estándar",
                "description": "Template básico para reportes generales",
                "sections": ["header", "summary", "content", "conclusions"]
            },
            "analytics": {
                "name": "Reporte de Analytics",
                "description": "Template para análisis de datos",
                "sections": ["header", "executive_summary", "data_analysis", "visualizations", "insights", "recommendations"]
            },
            "document_analysis": {
                "name": "Análisis Documental",
                "description": "Template para análisis de documentos",
                "sections": ["header", "document_info", "content_analysis", "key_findings", "summary"]
            }
        }
    
    # ===================================================================
    # GENERACIÓN PDF
    # ===================================================================
    
    async def generate_pdf_report(self, content: Dict[str, Any], request: ReportRequest) -> Dict[str, Any]:
        """Generar reporte PDF"""
        try:
            if not REPORTLAB_AVAILABLE:
                return await self.generate_fallback_report(content, "pdf")
            
            buffer = io.BytesIO()
            
            # Configurar documento
            doc = SimpleDocTemplate(
                buffer,
                pagesize=A4,
                rightMargin=72,
                leftMargin=72,
                topMargin=72,
                bottomMargin=72
            )
            
            # Estilos
            styles = getSampleStyleSheet()
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=24,
                spaceAfter=30,
                alignment=1,  # Centrado
                textColor=colors.darkblue
            )
            
            subtitle_style = ParagraphStyle(
                'CustomSubtitle',
                parent=styles['Heading2'],
                fontSize=16,
                spaceAfter=20,
                alignment=1,
                textColor=colors.grey
            )
            
            section_title_style = ParagraphStyle(
                'SectionTitle',
                parent=styles['Heading2'],
                fontSize=14,
                spaceAfter=12,
                textColor=colors.darkblue
            )
            
            # Elementos del documento
            elements = []
            
            # Título principal
            title = Paragraph(content["metadata"]["title"], title_style)
            elements.append(title)
            elements.append(Spacer(1, 12))
            
            # Subtítulo
            if content["metadata"].get("subtitle"):
                subtitle = Paragraph(content["metadata"]["subtitle"], subtitle_style)
                elements.append(subtitle)
                elements.append(Spacer(1, 20))
            
            # Información del reporte
            info_data = [
                ["Autor:", content["metadata"]["author"]],
                ["Fecha de generación:", content["metadata"]["generated_at"]],
                ["Template utilizado:", content["metadata"]["template"].title()],
                ["Número de secciones:", str(len(content["sections"]))]
            ]
            
            info_table = Table(info_data, colWidths=[2*inch, 4*inch])
            info_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),
                ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
                ('ALIGN', (0, 0), (0, -1), 'RIGHT'),
                ('ALIGN', (1, 0), (1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            
            elements.append(info_table)
            elements.append(Spacer(1, 30))
            
            # Secciones del contenido
            for section in content["sections"]:
                # Título de sección
                section_title = Paragraph(section["title"], section_title_style)
                elements.append(section_title)
                elements.append(Spacer(1, 12))
                
                # Contenido de sección
                if section["type"] == "text":
                    # Texto normal
                    paragraphs = section["content"].split('\n\n')
                    for para in paragraphs:
                        if para.strip():
                            text_para = Paragraph(para.strip(), styles['Normal'])
                            elements.append(text_para)
                            elements.append(Spacer(1, 6))
                
                elif section["type"] == "table" and section.get("formatted_table"):
                    # Tabla de datos
                    table_data = section["formatted_table"]
                    if table_data["rows"]:
                        # Limitar filas para PDF
                        pdf_rows = table_data["rows"][:15]  # Máximo 15 filas
                        pdf_table_data = [table_data["headers"]] + pdf_rows
                        
                        # Ajustar ancho de columnas
                        col_count = len(table_data["headers"])
                        col_width = 6.5 * inch / col_count
                        
                        table = Table(pdf_table_data, colWidths=[col_width] * col_count)
                        table.setStyle(TableStyle([
                            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                            ('FONTSIZE', (0, 0), (-1, 0), 10),
                            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                            ('FONTSIZE', (0, 1), (-1, -1), 8),
                            ('GRID', (0, 0), (-1, -1), 1, colors.black),
                            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])
                        ]))
                        
                        elements.append(table)
                        
                        # Nota si se truncaron filas
                        if len(table_data["rows"]) > 15:
                            note = Paragraph(f"<i>Nota: Mostrando primeras 15 filas de {len(table_data['rows'])} totales</i>", styles['Normal'])
                            elements.append(note)
                
                elif section["type"] == "analysis":
                    # Contenido de análisis
                    analysis_paras = section["content"].split('\n')
                    for para in analysis_paras:
                        if para.strip():
                            if para.startswith('##'):
                                # Subtítulo
                                subtitle_text = para.replace('##', '').strip()
                                subtitle_para = Paragraph(subtitle_text, styles['Heading3'])
                                elements.append(subtitle_para)
                            elif para.startswith('**') and para.endswith('**'):
                                # Texto en negrita
                                bold_text = para.replace('**', '')
                                bold_para = Paragraph(f"<b>{bold_text}</b>", styles['Normal'])
                                elements.append(bold_para)
                            else:
                                # Texto normal
                                text_para = Paragraph(para.strip(), styles['Normal'])
                                elements.append(text_para)
                    
                    # Resumen de análisis si existe
                    if section.get("analysis_summary"):
                        elements.append(Spacer(1, 10))
                        summary_para = Paragraph(f"<b>Resumen:</b> {section['analysis_summary']}", styles['Normal'])
                        elements.append(summary_para)
                
                elements.append(Spacer(1, 20))
            
            # Footer
            footer_style = ParagraphStyle(
                'Footer',
                parent=styles['Normal'],
                fontSize=8,
                alignment=1,
                textColor=colors.grey
            )
            
            elements.append(Spacer(1, 30))
            footer = Paragraph("Generado automáticamente por Agente IA OyP 6.0", footer_style)
            elements.append(footer)
            
            # Construir PDF
            doc.build(elements)
            
            # Obtener contenido
            pdf_content = buffer.getvalue()
            buffer.close()
            
            # Codificar en base64
            pdf_base64 = base64.b64encode(pdf_content).decode('utf-8')
            
            return {
                "content": pdf_base64,
                "content_type": "application/pdf",
                "size": len(pdf_content),
                "encoding": "base64",
                "filename": f"{content['metadata']['title'].replace(' ', '_')}.pdf"
            }
            
        except Exception as e:
            logger.error(f"❌ Error generando PDF: {e}")
            return await self.generate_fallback_report(content, "pdf")
    
    # ===================================================================
    # GENERACIÓN HTML
    # ===================================================================
    
    async def generate_html_report(self, content: Dict[str, Any], request: ReportRequest) -> Dict[str, Any]:
        """Generar reporte HTML"""
        try:
            html_template = """
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; padding: 40px; line-height: 1.6; 
            background-color: #f8f9fa; color: #333;
        }
        .container { 
            max-width: 1200px; margin: 0 auto; 
            background: white; padding: 40px; border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        .header { 
            text-align: center; border-bottom: 3px solid #007bff; 
            padding-bottom: 30px; margin-bottom: 40px; 
        }
        .title { 
            color: #007bff; font-size: 32px; margin-bottom: 10px; 
            font-weight: 300; letter-spacing: 1px;
        }
        .subtitle { 
            color: #6c757d; font-size: 20px; font-weight: 300; 
        }
        .info-box { 
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); 
            padding: 25px; border-radius: 8px; margin-bottom: 40px;
            border-left: 5px solid #007bff;
        }
        .info-grid {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 15px; font-size: 14px;
        }
        .info-item { display: flex; }
        .info-label { font-weight: bold; min-width: 140px; color: #495057; }
        .info-value { color: #212529; }
        .section { 
            margin-bottom: 40px; border-radius: 8px;
            border: 1px solid #e9ecef; overflow: hidden;
        }
        .section-header {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white; padding: 15px 25px; margin: 0;
            font-size: 20px; font-weight: 500;
        }
        .section-content { 
            padding: 25px; background: white;
        }
        .content { text-align: justify; }
        .content h2 { color: #007bff; font-size: 18px; margin-top: 25px; }
        .content h3 { color: #495057; font-size: 16px; }
        table { 
            width: 100%; border-collapse: collapse; margin: 20px 0; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1); border-radius: 8px;
            overflow: hidden;
        }
        th { 
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); 
            color: white; padding: 15px 12px; text-align: left; 
            font-weight: 600; font-size: 14px;
        }
        td { 
            border: 1px solid #e9ecef; padding: 12px; 
            background: white; font-size: 13px;
        }
        tr:nth-child(even) td { background-color: #f8f9fa; }
        tr:hover td { background-color: #e3f2fd; transition: all 0.3s ease; }
        .analysis { 
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%); 
            padding: 20px; border-radius: 8px; margin: 20px 0;
            border-left: 5px solid #ffc107;
        }
        .analysis h2 { color: #856404; margin-top: 0; }
        .footer { 
            text-align: center; margin-top: 60px; color: #6c757d; 
            font-size: 12px; padding-top: 20px; 
            border-top: 1px solid #e9ecef;
        }
        .stats-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px; margin: 20px 0;
        }
        .stat-card {
            background: white; padding: 20px; border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center;
        }
        .stat-number { font-size: 24px; font-weight: bold; color: #007bff; }
        .stat-label { color: #6c757d; font-size: 14px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">{{ title }}</h1>
            {% if subtitle %}<p class="subtitle">{{ subtitle }}</p>{% endif %}
        </div>
        
        <div class="info-box">
            <div class="info-grid">
                <div class="info-item">
                    <span class="info-label">Autor:</span>
                    <span class="info-value">{{ author }}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Fecha:</span>
                    <span class="info-value">{{ generated_at }}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Template:</span>
                    <span class="info-value">{{ template }}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Secciones:</span>
                    <span class="info-value">{{ section_count }}</span>
                </div>
            </div>
        </div>
        
        {% for section in sections %}
        <div class="section">
            <h2 class="section-header">{{ section.title }}</h2>
            <div class="section-content">
                {% if section.type == 'text' %}
                    <div class="content">
                        {% for paragraph in section.content.split('\n\n') %}
                            {% if paragraph.strip() %}
                                <p>{{ paragraph|replace('\n', '<br>')|safe }}</p>
                            {% endif %}
                        {% endfor %}
                    </div>
                {% elif section.type == 'table' and section.formatted_table %}
                    <table>
                        <thead>
                            <tr>
                                {% for header in section.formatted_table.headers %}
                                <th>{{ header }}</th>
                                {% endfor %}
                            </tr>
                        </thead>
                        <tbody>
                            {% for row in section.formatted_table.rows[:50] %}
                            <tr>
                                {% for cell in row %}
                                <td>{{ cell }}</td>
                                {% endfor %}
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                    {% if section.formatted_table.rows|length > 50 %}
                        <p><em>Mostrando primeras 50 filas de {{ section.formatted_table.rows|length }} totales</em></p>
                    {% endif %}
                {% elif section.type == 'analysis' %}
                    <div class="analysis">
                        {{ section.content|replace('##', '<h2>')|replace('\n', '<br>')|safe }}
                        {% if section.analysis_summary %}
                        <br><br><strong>Resumen:</strong> {{ section.analysis_summary }}
                        {% endif %}
                    </div>
                {% else %}
                    <div class="content">
                        <p>{{ section.content|replace('\n', '<br>')|safe }}</p>
                    </div>
                {% endif %}
            </div>
        </div>
        {% endfor %}
        
        <div class="footer">
            <p>📋 Generado automáticamente por <strong>Agente IA OyP 6.0</strong> - Report Generator Service</p>
            <p>Fecha de generación: {{ generated_at }}</p>
        </div>
    </div>
</body>
</html>
"""
            
            if JINJA2_AVAILABLE:
                template = Template(html_template)
                html_content = template.render(
                    title=content["metadata"]["title"],
                    subtitle=content["metadata"].get("subtitle"),
                    author=content["metadata"]["author"],
                    generated_at=content["metadata"]["generated_at"],
                    template=content["metadata"]["template"].title(),
                    section_count=len(content["sections"]),
                    sections=content["sections"]
                )
            else:
                # Fallback simple sin Jinja2
                html_content = html_template
                html_content = html_content.replace("{{ title }}", content["metadata"]["title"])
                html_content = html_content.replace("{{ author }}", content["metadata"]["author"])
                html_content = html_content.replace("{{ generated_at }}", content["metadata"]["generated_at"])
                html_content = html_content.replace("{{ template }}", content["metadata"]["template"])
                # Simplificar secciones para fallback
                sections_html = ""
                for section in content["sections"]:
                    sections_html += f"<div class='section'><h2 class='section-header'>{section['title']}</h2>"
                    sections_html += f"<div class='section-content'><p>{section['content']}</p></div></div>"
                html_content = html_content.replace("{% for section in sections %}...{% endfor %}", sections_html)
            
            return {
                "content": html_content,
                "content_type": "text/html",
                "size": len(html_content.encode('utf-8')),
                "encoding": "utf-8",
                "filename": f"{content['metadata']['title'].replace(' ', '_')}.html"
            }
            
        except Exception as e:
            logger.error(f"❌ Error generando HTML: {e}")
            return await self.generate_fallback_report(content, "html")
    
    # ===================================================================
    # GENERACIÓN JSON
    # ===================================================================
    
    async def generate_json_report(self, content: Dict[str, Any], request: ReportRequest) -> Dict[str, Any]:
        """Generar reporte JSON"""
        try:
            json_content = json.dumps(content, indent=2, ensure_ascii=False)
            
            return {
                "content": json_content,
                "content_type": "application/json",
                "size": len(json_content.encode('utf-8')),
                "encoding": "utf-8",
                "filename": f"{content['metadata']['title'].replace(' ', '_')}.json"
            }
            
        except Exception as e:
            logger.error(f"❌ Error generando JSON: {e}")
            return await self.generate_fallback_report(content, "json")
    
    async def generate_fallback_report(self, content: Dict[str, Any], format_type: str) -> Dict[str, Any]:
        """Generar reporte de respaldo"""
        try:
            fallback_content = f"""
REPORTE - {content['metadata']['title']}
{'=' * 50}

Autor: {content['metadata']['author']}
Fecha: {content['metadata']['generated_at']}
Template: {content['metadata']['template']}

CONTENIDO:
"""
            
            for i, section in enumerate(content.get("sections", []), 1):
                fallback_content += f"\n{i}. {section['title']}\n"
                fallback_content += f"{'-' * 30}\n"
                fallback_content += f"{section['content']}\n"
                if section.get("analysis_summary"):
                    fallback_content += f"Resumen: {section['analysis_summary']}\n"
                fallback_content += "\n"
            
            fallback_content += f"\nGenerado por Agente IA OyP 6.0 (Report Generator - Modo Respaldo)\nFormato solicitado: {format_type}"
            
            return {
                "content": fallback_content,
                "content_type": "text/plain",
                "size": len(fallback_content.encode('utf-8')),
                "encoding": "utf-8",
                "fallback": True,
                "filename": f"{content['metadata']['title'].replace(' ', '_')}_fallback.txt"
            }
            
        except Exception as e:
            logger.error(f"❌ Error generando fallback: {e}")
            return {
                "content": f"Error generando reporte: {str(e)}",
                "content_type": "text/plain",
                "size": 0,
                "encoding": "utf-8",
                "error": True
            }

# ===================================================================
# INSTANCIA GLOBAL DEL SERVICIO
# ===================================================================

report_service = ReportGeneratorService()

# ===================================================================
# ENDPOINTS DE LA API
# ===================================================================

@app.get("/")
async def root():
    """Endpoint raíz con información del servicio"""
    return {
        "message": "📋 Bienvenido al Generador de Reportes - Agente IA OyP 6.0",
        "service": "report-generator",
        "version": "6.0.0",
        "status": "active",
        "supported_formats": ["pdf", "html", "json"],
        "capabilities": [
            "pdf_generation",
            "html_reports",
            "json_export",
            "template_system",
            "automatic_sections",
            "table_formatting",
            "analysis_integration"
        ]
    }

@app.get("/health")
async def health_check():
    """Health check del servicio"""
    return {
        "status": "healthy",
        "service": "report-generator",
        "port": 8004,
        "timestamp": datetime.now().isoformat(),
        "dependencies": {
            "reportlab": REPORTLAB_AVAILABLE,
            "jinja2": JINJA2_AVAILABLE
        },
        "generated_reports": len(report_service.generated_reports),
        "available_templates": len(report_service.templates)
    }

@app.get("/info")
async def service_info():
    """Información detallada del servicio"""
    return {
        "name": "report-generator",
        "description": "Generador automático de reportes profesionales en múltiples formatos",
        "port": 8004,
        "version": "6.0.0",
        "endpoints": {
            "GET /": "Información del servicio",
            "GET /health": "Health check",
            "GET /info": "Información detallada",
            "POST /generate": "Generar reporte completo",
            "POST /quick_report": "Generar reporte rápido",
            "GET /templates": "Listar templates disponibles",
            "GET /reports": "Listar reportes generados",
            "GET /report/{id}": "Obtener información de reporte"
        }
    }

@app.post("/generate")
async def generate_report_endpoint(request: ReportRequest):
    """Generar reporte completo"""
    return await report_service.generate_report(request)

@app.post("/quick_report")
async def quick_report(request: QuickReportRequest):
    """Generar reporte rápido con contenido simple"""
    full_request = ReportRequest(
        title=request.title,
        author=request.author,
        format=request.format,
        sections=[{
            "title": "Contenido Principal",
            "type": "text",
            "content": request.content
        }]
    )
    
    return await report_service.generate_report(full_request)

@app.get("/templates")
async def list_templates():
    """Listar templates disponibles"""
    return {
        "templates": report_service.templates,
        "total_templates": len(report_service.templates)
    }

@app.get("/reports")
async def list_reports():
    """Listar reportes generados"""
    return {
        "reports": list(report_service.generated_reports.values()),
        "total_reports": len(report_service.generated_reports)
    }

@app.get("/report/{report_id}")
async def get_report_info(report_id: str):
    """Obtener información de reporte específico"""
    if report_id in report_service.generated_reports:
        return report_service.generated_reports[report_id]
    else:
        raise HTTPException(status_code=404, detail="Reporte no encontrado")

@app.delete("/report/{report_id}")
async def delete_report(report_id: str):
    """Eliminar reporte del caché"""
    if report_id in report_service.generated_reports:
        del report_service.generated_reports[report_id]
        return {"message": "Reporte eliminado", "report_id": report_id}
    else:
        raise HTTPException(status_code=404, detail="Reporte no encontrado")

@app.get("/statistics")
async def get_generation_statistics():
    """Estadísticas del servicio de generación"""
    reports = report_service.generated_reports
    
    # Estadísticas por formato
    format_stats = {}
    for report in reports.values():
        format_type = report.get('format', 'unknown')
        format_stats[format_type] = format_stats.get(format_type, 0) + 1
    
    # Estadísticas por template
    template_stats = {}
    for report in reports.values():
        if 'request' in report:
            template = report['request'].get('template', 'unknown')
            template_stats[template] = template_stats.get(template, 0) + 1
    
    return {
        "total_reports_generated": len(reports),
        "reports_by_format": format_stats,
        "reports_by_template": template_stats,
        "service_uptime": datetime.now().isoformat(),
        "dependencies_status": {
            "pdf_generation": REPORTLAB_AVAILABLE,
            "html_templates": JINJA2_AVAILABLE
        },
        "available_templates": list(report_service.templates.keys())
    }

@app.post("/test_generation")
async def test_report_generation():
    """Endpoint para probar la generación de reportes"""
    test_request = ReportRequest(
        title="Reporte de Prueba",
        subtitle="Generado automáticamente para verificar funcionalidad",
        author="Sistema de Pruebas",
        format="html",
        sections=[
            {
                "title": "Introducción",
                "type": "text",
                "content": "Este es un reporte de prueba generado automáticamente para verificar que el servicio de generación de reportes funciona correctamente."
            },
            {
                "title": "Datos de Ejemplo",
                "type": "table",
                "content": "Tabla con datos de ejemplo para demostrar las capacidades.",
                "data": {
                    "headers": ["ID", "Nombre", "Valor", "Estado"],
                    "rows": [
                        ["1", "Item A", "100", "Activo"],
                        ["2", "Item B", "200", "Inactivo"],
                        ["3", "Item C", "150", "Activo"]
                    ]
                }
            },
            {
                "title": "Análisis",
                "type": "analysis",
                "content": "## Resultados del Análisis\n\nEl análisis muestra resultados satisfactorios:\n\n**Elementos activos**: 2 de 3 (66.7%)\n\n**Valor promedio**: 150",
                "data": {
                    "mean": 150,
                    "count": 3,
                    "active_percentage": 66.7
                }
            }
        ]
    )
    
    return await report_service.generate_report(test_request)

# ===================================================================
# INICIALIZACIÓN DEL SERVICIO
# ===================================================================

if __name__ == "__main__":
    logger.info("🚀 Iniciando Report Generator Service...")
    logger.info("📍 Puerto: 8004")
    logger.info("📖 Documentación: http://localhost:8004/docs")
    logger.info(f"📄 ReportLab: {'✅' if REPORTLAB_AVAILABLE else '❌'}")
    logger.info(f"🎨 Jinja2: {'✅' if JINJA2_AVAILABLE else '❌'}")
    logger.info(f"📁 Reports dir: {REPORTS_DIR}")
    logger.info("📋 Formatos soportados: PDF, HTML, JSON")
    
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8004,
        reload=True,
        log_level="info"
    )
app = FastAPI(
    title="📋 Generador de Reportes - Agente IA OyP 6.0",
    description="Generador automático de reportes profesionales en PDF, HTML y JSON",
    version="6.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Configurar CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

    
    def setup_templates(self) -> Dict[str, Any]:
        """Configurar templates predefinidos"""
        return {
            "standard": {
                "name": "Reporte Estándar",
                "description": "Template básico para reportes generales",
                "sections": ["header", "summary", "content", "conclusions"]
            },
            "analytics": {
                "name": "Reporte de Analytics",
                "description": "Template para análisis de datos",
                "sections": ["header", "executive_summary", "data_analysis", "visualizations", "insights", "recommendations"]
            },
            "document_analysis": {
                "name": "Análisis Documental",
                "description": "Template para análisis de documentos",
                "sections": ["header", "document_info", "content_analysis", "key_findings", "summary"]
            }
        }
    
    # ===================================================================
    # GENERACIÓN DE REPORTES
    # ===================================================================
    
    async def generate_report(self, request: ReportRequest) -> Dict[str, Any]:
        """Generar reporte completo"""
        try:
            report_id = f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            # Construir contenido del reporte
            report_content = await self.build_report_content(request)
            
            # Generar según formato
            if request.format == "pdf":
                report_data = await self.generate_pdf_report(report_content, request)
            elif request.format == "html":
                report_data = await self.generate_html_report(report_content, request)
            elif request.format == "json":
                report_data = await self.generate_json_report(report_content, request)
            else:
                raise ValueError(f"Formato {request.format} no soportado")
            
            # Guardar reporte
            self.generated_reports[report_id] = {
                "id": report_id,
                "title": request.title,
                "format": request.format,
                "generated_at": datetime.now().isoformat(),
                "size": len(str(report_data.get("content", ""))),
                "request": request.dict()
            }
            
            return {
                "report_id": report_id,
                "title": request.title,
                "format": request.format,
                "generated_at": datetime.now().isoformat(),
                "status": "completed",
                **report_data
            }
            
        except Exception as e:
            logger.error(f"❌ Error generando reporte: {e}")
            raise HTTPException(status_code=500, detail=f"Error generando reporte: {str(e)}")
    
    async def build_report_content(self, request: ReportRequest) -> Dict[str, Any]:
        """Construir contenido estructurado del reporte"""
        try:
            content = {
                "metadata": {
                    "title": request.title,
                    "subtitle": request.subtitle,
                    "author": request.author,
                    "generated_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "template": request.template
                },
                "sections": [],
                "statistics": {}
            }
            
            # Procesar secciones del request
            for section_data in request.sections:
                processed_section = await self.process_section(section_data)
                content["sections"].append(processed_section)
            
            # Generar secciones automáticas si hay datos
            if request.data:
                auto_sections = await self.generate_auto_sections(request.data, request.template)
                content["sections"].extend(auto_sections)
            
            return content
            
        except Exception as e:
            logger.error(f"❌ Error construyendo contenido: {e}")
            raise ValueError(f"Error construyendo contenido: {str(e)}")
    
    async def process_section(self, section_data: Dict[str, Any]) -> Dict[str, Any]:
        """Procesar una sección individual"""
        try:
            processed = {
                "title": section_data.get("title", "Sin título"),
                "type": section_data.get("type", "text"),
                "content": section_data.get("content", ""),
                "data": section_data.get("data", {})
            }
            
            # Procesamiento específico por tipo
            if processed["type"] == "table" and processed["data"]:
                processed["formatted_table"] = self.format_table_data(processed["data"])
            elif processed["type"] == "analysis" and processed["data"]:
                processed["analysis_summary"] = self.generate_analysis_summary(processed["data"])
            
            return processed
            
        except Exception as e:
            logger.error(f"❌ Error procesando sección: {e}")
            return {"title": "Error", "content": f"Error procesando sección: {str(e)}"}
    
    async def generate_auto_sections(self, data: Dict[str, Any], template: str) -> List[Dict[str, Any]]:
        """Generar secciones automáticas basadas en datos"""
        try:
            sections = []
            
            # Sección de resumen de datos
            if "statistics" in data or "summary" in data:
                sections.append({
                    "title": "Resumen Ejecutivo",
                    "type": "analysis",
                    "content": self.generate_executive_summary(data),
                    "data": data.get("statistics", {})
                })
            
            # Sección de análisis de datos
            if "analysis" in data:
                sections.append({
                    "title": "Análisis de Datos",
                    "type": "analysis",
                    "content": self.format_analysis_results(data["analysis"]),
                    "data": data["analysis"]
                })
            
            # Sección de tablas
            if "tables" in data or "dataframe" in data:
                sections.append({
                    "title": "Datos Tabulares",
                    "type": "table",
                    "content": "Presentación de los datos en formato tabular para análisis detallado.",
                    "data": data.get("tables", data.get("dataframe", []))
                })
            
            # Sección de hallazgos clave
            if "insights" in data or "findings" in data:
                sections.append({
                    "title": "Hallazgos Principales",
                    "type": "text",
                    "content": data.get("insights", data.get("findings", "")),
                    "data": {}
                })
            
            # Sección de recomendaciones
            if "recommendations" in data:
                sections.append({
                    "title": "Recomendaciones",
                    "type": "text",
                    "content": data["recommendations"],
                    "data": {}
                })
            
            return sections
            
        except Exception as e:
            logger.error(f"❌ Error generando secciones automáticas: {e}")
            return []
    
    def generate_executive_summary(self, data: Dict[str, Any]) -> str:
        """Generar resumen ejecutivo"""
        try:
            summary_parts = []
            
            # Información del dataset
            if "statistics" in data:
                stats = data["statistics"]
                if "rows" in stats and "columns" in stats:
                    summary_parts.append(f"**Datos analizados:** {stats['rows']:,} registros con {stats['columns']} variables.")
                
                if "data_quality" in stats:
                    quality = stats["data_quality"]
                    completeness = quality.get("completeness", 0)
                    summary_parts.append(f"**Calidad de datos:** {completeness:.1f}% de completitud.")
            
            # Correlaciones significativas
            if "correlations" in data:
                corr_data = data["correlations"]
                if "strong_correlations" in corr_data:
                    strong_count = len(corr_data["strong_correlations"])
                    if strong_count > 0:
                        summary_parts.append(f"**Correlaciones identificadas:** {strong_count} correlaciones estadísticamente significativas.")
            
            # Clustering
            if "clustering" in data:
                cluster_data = data["clustering"]
                if "optimal_clusters" in cluster_data:
                    clusters = cluster_data["optimal_clusters"]
                    summary_parts.append(f"**Segmentación:** Los datos se organizan naturalmente en {clusters} grupos distintos.")
            
            # Outliers
            if "outliers" in data:
                outlier_data = data["outliers"]
                total_outliers = sum(info.get("count", 0) for info in outlier_data.values() if isinstance(info, dict))
                if total_outliers > 0:
                    summary_parts.append(f"**Valores atípicos:** Se detectaron {total_outliers} valores que requieren atención especial.")
            
            if not summary_parts:
                summary_parts.append("Se ha completado el análisis de los datos proporcionados con resultados satisfactorios.")
            
            return "\n\n".join(summary_parts)
            
        except Exception as e:
            logger.error(f"❌ Error generando resumen ejecutivo: {e}")
            return "Resumen ejecutivo no disponible debido a un error en el procesamiento."
    
    def format_analysis_results(self, analysis: Dict[str, Any]) -> str:
        """Formatear resultados de análisis"""
        try:
            content_parts = []
            
            # Estadísticas descriptivas
            if "descriptive_stats" in analysis:
                content_parts.append("## Estadísticas Descriptivas\n")
                content_parts.